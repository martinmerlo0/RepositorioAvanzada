{-Para tener en cuenta algunos conceptos: por subsegmento de xs o subse-
cuencia de xs entendemos a cualquier lista cuyos elementos est ́an en xs, en el

mismo orden y consecutivamente. Por ejemplo, si la lista es xs = [1, 4, 2, 1, 1, 8, 7]
los siguientes son ejemplos de subsegmentos :
• secuencia vac ́ıa: [].
• subsegmento unitario [4].
• subsegmento inicial [1, 4].
• [2, 1, 1].
• [1, 4, 2, 1, 1, 8, 7].
• subsegmento final [8, 7].











Ejercicio 4. Especificar lo siguiente:
• Dada una lista de enteros, especifique la suma del subsegmento de suma
m ́ınima de la lista. Por ejemplo, si la lista es xs = [1, −4, −2, 1, −5, 8, −7]
el subsegmento que da la suma m ́ınima es [−4, −2, 1, −5], cuya suma es
-10. Si xs = [1, 3, 5] , el subsegmento que da la suma m ́ınima es [] , pues
la suma de la lista vac ́ıa es cero.

• Especifique la funcin maxigual que determina la longitud del m ́aximo sub-
segmento en donde todos sus elementos son iguales: maxigual : [A]− >

Num.

• Especifique la funci ́on maxdistinto : [Int]− > Int que determina la longi-
tud del subsegmento m ́as largo en donde todos los elementos son distintos.

Ejercicio 5. Dadas las funciones split3 : [a]− > [([a], [a], [a])] y split2 : [a]− >
[([a], [a])] dadas en clases. Escribir las siguientes especificaciones usando listas
por comprensi ́on:
• La especificaci ́on del ejercicio 1(e).
• La especificaci ́on del ejercicio 3(c).
• La especificaci ́on del ejercicio 3(d).
• La siguiente especificaci ́on: Dada una lista de n ́umeros, calcular el valor
de subsegmento de suma m ́axima.-}










Ejercicio 1. Expresar en lenguaje formal (de primer orden) las siguientes
especificaciones.
-----------------------------------------------------------

• f es una funci ́on que determina si los elementos de una lista xs son iguales.

(∀i : 0 <= i < #xs : xs.0 = xs.i) --Todos son iguales al primero

-------------------------------------------------------------

• f es una funci ́on que determina si los elementos de una lista xs son todos
diferentes.


(∀i,j : 0 <= i < #xs ∧ 0 <= j < #xs ∧ i != j : xs.i != xs.j)

-------------------------------------------------------------

• f es una funci ́on que determina si los elementos de una lista xs est ́an
ordenados.


(∀i : 0 <= i < #xs-1 : xs.i < xs.i+1)
-------------------------------------------------------------


• P es un predicado que es true sii cuando aparece 1 en xs entonces debe
aparecer 0 en xs.


(∃i : 0 <= i < #xs : xs.i = 1) then (∃i : 0 <= i < #xs : xs.i = 0)

-------------------------------------------------------------


• p es el producto de todos los elementos primos de xs.


(∏i : 0 <= i < #xs ∧ primos xs.i : xs.i) 

{Si se cumple que i esta en el rango y aparte el elemento en ese indice es primo
entonces se considera el termino y lo multiplica}


-------------------------------------------------------------



Lista de booleanos -> [Bool]

Ejercicio 2. Sea xs un lista no vacıa con elementos booleanos, tal que true
aparezca al menos una vez en la lista. Especificar:
-------------------------------------------------

• n es el menor entero tal que xs.n = true.

menorEntero :: [Bool] -> Int
menorEntero xs = (Min i : 0 <= i < #xs y xs.i : i)

--------------------------------

• n es el  ́ultimo elemento de la lista tal que xs.n = true.

mayorEntero :: [Bool] -> Int
mayorEntero xs = (Max i : 0 <= i < #xs y xs.i : i)


--------------------------------------

• f es una funci ́on que devuelve true si y solo si todos los elementos de xs
son equivalentes.

equivalentes :: [Bool] -> Int
equivalentes xs = (∀i : 0 <= i < #xs : xs.i)

{Si hay algun elemento que es distinto de True la funcion devuelve falso puesto
que el para todo funciona como una conjuncion del termino es decir 
xs.0 y xs.1 y xs.2 y ... y xs.n si por ej xs.2 es falso la conjuncion ya es falsa }




Ejercicio 3. Especificar las siguientes funciones:



• f.xs determina si xs tiene la misma cantidad de pares que impares.

f :: [Int] -> Bool 
f xs = (Ni : 0 <= i < #xs : esPar xs.i) == (Ni : 0 <= i <= #xs : impar xs.i)

-------------------------------------------------

• f.n determina si n es primo.

f :: Int -> Bool
f n = (∀i : i = n : esPrimo i)



• f.xs.ys determina si ys es una subsecuencia de xs.

f :: [a] -> [a] -> Bool
f xs ys = (∃ as,bs : ys = as ++ xs ++ bs)




• f.xs.ys determina si ys es una subsecuencia final de xs.

f :: [a] -> [a] -> Bool
f xs ys = (∃ as , bs : ys = as ++ bs ++ xs) 